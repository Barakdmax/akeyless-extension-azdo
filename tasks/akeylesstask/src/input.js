const tl = require('azure-pipelines-task-lib/task');
const auth = require('./auth');

const stringInputs = {
  accessId: 'accessId',
  azureJwt: 'azureJwt'
};

const dictInputs = {
  staticSecrets: 'staticSecrets',
  dynamicSecrets: 'dynamicSecrets'
};

const boolInputs = {
  exportSecretsToOutputs: 'exportSecretsToOutputs',
  exportSecretsToEnvironment: 'exportSecretsToEnvironment',
  parseDynamicSecrets: 'parseDynamicSecrets'
};

const fetchAndValidateInput = () => {
  const params = {
    accessId: tl.getInput('accessId', true),
    azureJwt: tl.getInput('azureJwt', true),
    staticSecrets: tl.getInput('staticSecrets'),
    dynamicSecrets: tl.getInput('dynamicSecrets'),
    exportSecretsToOutputs: tl.getBoolInput('exportSecretsToOutputs'),
    exportSecretsToEnvironment: tl.getBoolInput('exportSecretsToEnvironment'),
    parseDynamicSecrets: tl.getBoolInput('parseDynamicSecrets')
  };

  // required inputs
  if (!params['accessId']) {
    throw new Error('You must provide the access id for your auth method via the accessId input');
  }

  if (!params['azureJwt']) {
    throw new Error('You must provide a JWT token for Azure authentication, this is generated by a Service connection and Azure CLI.');
  }

  // check for string types
  for (const [paramKey, inputId] of Object.entries(stringInputs)) {
    if (typeof params[paramKey] !== 'string') {
      throw new Error(`Input '${inputId}' should be a string`);
    }
  }

  // check for bool types
  for (const [paramKey, inputId] of Object.entries(boolInputs)) {
    if (typeof params[paramKey] !== 'boolean') {
      throw new Error(`Input '${inputId}' should be a boolean`);
    }
  }

  // check for dict types
  for (const [paramKey, inputId] of Object.entries(dictInputs)) {
    if (typeof params[paramKey] !== 'string') {
      throw new Error(`Input '${inputId}' should be a serialized JSON dictionary with the secret path as a key and the output name as the value`);
    }
    if (!params[paramKey]) {
      continue;
    }
    try {
      const parsed = JSON.parse(params[paramKey]);
      if (parsed.constructor !== Object) {
        throw new Error(`Input '${inputId}' did not contain a valid JSON dictionary`);
      }
      params[paramKey] = parsed;
    } catch (e) {
      if (e instanceof SyntaxError) {
        throw new Error(`Input '${inputId}' did not contain valid JSON`);
      } else {
        throw e;
      }
    }
  }

  return params;
};

exports.fetchAndValidateInput = fetchAndValidateInput;
