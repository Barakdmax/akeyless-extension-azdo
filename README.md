# AKeyless Extension for Azure DevOps

Use this Azure DevOps extension to safely retrieve and use secrets from your AKeyless vault. The task will login to AKeyless using Azure service connection JWT authentication and then fetch static secrets or a dynamic secret producer.

- [AKeyless Extension for Azure DevOps](#akeyless-extension-for-azure-devops)
    - [Inputs](#inputs)
    - [Outputs](#outputs)
    - [Static Secrets Outputs](#static-secrets-outputs)
      - [Dynamic Secrets Output](#dynamic-secrets-output)
  - [AKeyless Setup](#akeyless-setup)
    - [Authentication](#authentication)
  - [Examples](#examples)

### Inputs

| Name | Required | Type | Value |
|------|----------|------|-------|
| accessId | Yes | `string`  | The access id for your auth method |
| azureJwt  | Yes | `string`  | This is the JWT you recieved in a previous step (e.g., `$JWT=$(az account get-access-token --query accessToken --output tsv)`) |
| staticSecrets | No | `string` | A JSON object as a string, with a list of static secrets to fetch/export. The key should be the path to the secret and the value should be the name of the environment variable/output to save it to. **See examples**. |
| dynamicSecrets | No | `string` | A JSON object as a string, with a list of dynamic secrets to fetch/export. The key should be the path to the secret and the value should be the name of the environment variable/output to save it to. **See examples**. |

> [!IMPORTANT]
> When defining the secrets, you need to make sure the input's format is correct. For example, a single secret would be `{"/path/to/secret":"my_secret" }` or for multiple secrets `{"/path/to/first-secret":"first_secret", "/path/to/second-secret":"second_secret" }`.


### Outputs

The task's outputs are determined by the values set in your `statiSecrets` and `dynamicSecrets` inputs. Whatever you have set for the secrets names will be turned into pipeline secret output variables for the task.

### Static Secrets Outputs

For static secrets, you will get an individual secret output variables for each secret. For example:

```yaml
steps:
- task: AzureCLI@2
  displayName: AzureCLI
  inputs:
    azureSubscription: 'My Azure Service Principal'
    scriptType: ps
    scriptLocation: inlineScript
    inlineScript: |
     $JWT=$(az account get-access-token --query accessToken --output tsv)
     echo "##vso[task.setvariable variable=azure_jwt;isoutput=true;issecret=true]$JWT"

- task: LancelotSoftware.akeylessExtensionsAzdo.akeyless-extensions-task.akeylessExtensionAzdo@0
  displayName: MyAkeylessTask
  inputs:
    accessid: 'p-123456'
    azureJwt: '$(AzureCLI.azure_jwt)'
    staticSecrets: '{"/path/to/first-secret":"first_secret", "/path/to/second-secret":"second_secret" }'
```
Notice how we are using the `azure_jwt` output from the AzureCLI task to hold the JWT, then use it in the Akeyless task with `$(AzureCLI.azure_jwt)`.

You will have `$(MyAkeylessTask.first_secret)` and  `$(MyAkeylessTask.second_secret)` available in subsequent tasks of that job.

#### Dynamic Secrets Output

For dynamic secret, it will only be a single variable. For example:

```yaml
steps:
- task: AzureCLI@2
  displayName: AzureCLI
  inputs:
    azureSubscription: 'My Azure Service Principal'
    scriptType: ps
    scriptLocation: inlineScript
    inlineScript: |
     $FRESH_JWT=$(az account get-access-token --query accessToken --output tsv)
     echo "##vso[task.setvariable variable=azure_jwt;isoutput=true;issecret=true]$FRESH_JWT"

- task: LancelotSoftware.akeylessExtensionsAzdo.akeyless-extensions-task.akeylessExtensionAzdo@0
  displayName: MyAkeylessTask
  inputs:
    accessid: 'p-123456'
    azureJwt: '$(AzureCLI.azure_jwt)'
    staticSecrets: '{"/path/to/dynamic/secret":"my_dynamic_secret"}'
```

Notice how we are using the `azure_jwt` output from the AzureCLI task to hold the JWT, then use it in the Akeyless task with `$(AzureCLI.azure_jwt)`.

You will have `$(MyAkeylessTask.my_dynamic_secret)` available in subsequent tasks of that job. Note that dynamic secrets tend to be large complex objects and you will likely need to further process the value to get an inner value. For example, using `jq`.

## AKeyless Setup

### Authentication

This action supports authenticating with AKeyless using JWT generated by an Azure service principal (via the pipeline's Service connections setting).

To configure AKeyless and grant your repositories the necessary permissions:

1. Create a new JWT Auth method in AKeyless if you don't have one (you can safely share the auth method between repositories)
    1. In AKeyless go to "Auth Methods" -> "+ New" -> "OAuth 2.0/JWT".
    2. Specify a name (e.g. "Azure JWT Auth") and location of your choice.
    3. For the JWKS Url, specify `https://login.microsoftonline.com/common/discovery/keys`
    4. For the unique identifier use `tenantId`. See note (1) below for more details.
    5. You **MUST** click "Require Sub Claim on role association".  This will prevent you from attaching this to a role without any additional checks **that make this a critical checkbox!!!**
2. Create an appropriate access role (if you don't already have one)
    1. In AKeyless go to "Access Roles" -> "+ New"
    2. Give it a name and location, and create it.
    3. Find your new access role and click on it to edit it.
    4. On the right side, under "Secrets & Keys", click the "Add" button to configure read access to any static or dynamic secrets you will fetch from your pipeline.
3. Attach your Azure JWT Auth method to your access role
    1. Once again, find the access role you created in step #2 above and click on it to edit it.
    2. Hit the "+ Associate" button to associate your newly created auth method with this access role.
    3. In the list, find the auth method you created in Step #1 above (we named it "Azure JWT Auth")
    4. Add an appropriate subclaim. **See note (2) below for more details.**
    5. Save!

After following these steps, you'll be ready to use JWT Auth from your Azure DevOps

**(1) Note:** The unique identifier is mainly used for auditing/billing purposes, so there isn't one correct answer here.  `tenantId` or even `appId` is a sensible default. If you are uncertain, talk to AKeyless for more details.

**(2) Note:** Subclaim checks allow AKeyless to grant access to specific workflows, based on the claims that are provided in the JWT. We **strongly** recommend restricting the access by using the service principal's `appId` for the required subclaim.

For Azure Service Principal, here is a small portion of the subclaims map that akeyless can use:

```
[
  appid:[your-service-principal-app-id] 
  aud:[https://management.core.windows.net/]
  idp:[https://sts.windows.net/your-tenant-id/]
  iss:[https://sts.windows.net/your-tenant-id/]
  sub:[your-subscription-id] 
  tid:[your-tenant-id] 
  ...
]
```

Using the `appId` allows you to make sure only that exact service principal can access the secrets. While using a tenantId allos any service principal in the org to access them. Choose appropriately for your needs.

## Examples

Here are some examples you can use for guidance:
